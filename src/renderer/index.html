<!doctype html>
<html lang='en'>
	<head>
		<meta charset='utf-8'>
		<title>MC Model Vision</title>
		<link rel='stylesheet' type='text/css' href='css/fomantic.css'>
		<style type='text/css'>
			body {
				margin: 0;
				height: 100vh;
				width: 100vw;
			}

			#container {
				width: 100%;
				height: 100%;
				background-color: #ddd;
			}

			.bottom-right-corner {
				position: fixed;
				bottom: 1rem;
				right: 1rem;
			}

			.top-left-corner {
				position: fixed;
				top: 1rem;
				left: 1rem;
			}
		</style>
	</head>
	<body>
		<div id='container'>
			<div class='ui mini blue icon buttons bottom-left-corner'>
				<button class='ui button' id='fullScreenBtn'>
					<i class='expand icon'></i>
				</button>
				<button class='ui button' id='screenshotBtn'>
					<i class='camera icon'></i>
				</button>
			</div>
		</div>
		<script type='text/javascript' src='js/three.min.js'></script>
		<script type='text/javascript' src='js/OrbitControls.js'></script>
		<script type='text/javascript' src='js/modelRenderer.js'></script>
		<script type='text/javascript'>
			const { dialog } = require('electron').remote;
			const containerElem = document.getElementById('container');
			let renderer, camera, scene, controls, currentFile;

			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(
					70,
					window.innerWidth / window.innerHeight,
					0.01,
					1000,
			);
			camera.position.set(16, 16, 64);

			renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			containerElem.appendChild(renderer.domElement);

			// Create the controls
			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.enableKeys = false;
			controls.enablePan = false;
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;
			controls.autoRotate = true;

			// Update the dimensions of the viewport when the window gets resized
			window.addEventListener('resize', function() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});

			// Start animation
			function animate() {
				requestAnimationFrame(animate);
				controls.update();
				renderer.render(scene, camera);
			}

			animate();

			const saveAsImage = () => {
				var imgData, imgNode;
				try {
					var strMime = 'image/png';
					imgData = renderer.domElement.toDataURL(strMime);
					saveFile(imgData, 'screenshot.png');
				} catch (e) {
					console.log(e);
				}
			};

			const saveFile = (strData, filename) => {
				var link = document.createElement('a');
				document.body.appendChild(link);
				link.download = filename;
				link.href = strData;
				link.click();
				document.body.removeChild(link);
			};

			const setFullScreen = (fullScreen) => {
				if (fullScreen) {
					if (containerElem.requestFullscreen) containerElem.requestFullscreen();
					else if (containerElem.mozRequestFullScreen) containerElem.mozRequestFullScreen();
					else if (containerElem.webkitRequestFullscreen) containerElem.webkitRequestFullscreen();
					else if (containerElem.msRequestFullscreen) containerElem.msRequestFullscreen();

					containerElem.style.width = '100%';
					containerElem.style.height = '100%';
				}
			};

			document.getElementById('screenshotBtn').onclick = () => saveAsImage();
			document.getElementById('fullScreenBtn').onclick = () => setFullScreen(true);

			document.getElementById('openBtn', () => {
				dialog.showOpenDialog((fileNames) => {
					if(fileNames === undefined){
						console.log("No file selected");
						return;
					}

					new MinecraftModelLoader().load(fileNames[0], mesh => {
						const textureLoader = new MinecraftTextureLoader();
						mesh.resolveTextures(path =>
								textureLoader.load(
										`./static/mc_assets/${path.split(/\:/g)[0]}/textures/${
												path.split(/\:/g)[1]
										}.png`,
								),
						);
						scene.add(mesh);
					});
				});
			});
		</script>
	</body>
</html>
